// MAP 562
// G. Allaire, B. Bogosel

// Geometric optimization of a parametric hole

real a=0.5,b=0.3,l=2.5;
real cx = 0,cy=0;
int maxiter = 2;
real maxstep = 0.01;
real ratio = 1;

real fixedV = 1;

real step = 0.01;

verbosity = 0;

real alpha =0.5;

real E=1;			// Young modulus
real nu=0.3;			// Poisson coefficient (between -1 and 1/2)

real lambda=E*nu/((1.+nu)*(1.-2.*nu));
real mu=E/(2.*(1.+nu));

int NN = 10;
int Ni = 10;

int GammaD = 0,GammaN = 1,Gamma0=20;

border left(t=l,-l){x=-l;y=t;label=GammaD;}
border bot(t=-l,l){x=t;y=-l;label=GammaN;}
border right(t=-l,l){x=l;y=t;label=GammaN;}
border top(t=l,-l){x=t;y=l;label=GammaN;}

// Parametric boundary
border superellipse(t=0,2*pi){
   x = a*((cos(t)>0)-(cos(t)>0))*sqrt(abs(cos(t)))+cx;
   y = b*((sin(t)>0)-(sin(t)>0))*sqrt(abs(sin(t)))+cy;
   label = Gamma0;
}
border axe(t=-a,a){x=t;y=0;label=100;}
macro projparams(a,b)
      mesh Thhole = buildmesh(superellipse(Ni*(a+b)*pi*NN));
      ratio = sqrt(Thhole.area/fixedV);
      a = a/ratio;
      b = b/ratio;//

projparams(a,b);

mesh Th = buildmesh(left(2*NN)+bot(2*NN)+right(2*NN)+top(2*NN)
                   +superellipse(Ni*(a+b)*pi*NN));

plot(Th);

fespace Vh(Th,P1);
fespace Vh0(Th,P0);

Vh ux,uy,vx,vy;


real sqrt2 = sqrt(2);
macro e(ux,uy) [dx(ux),dy(uy),(dx(uy)+dy(ux))/sqrt2]//
macro div(ux,uy) (dx(ux)+dy(uy))//
macro Aeueu(ux,uy) (2*mu*e(ux,uy)'*e(ux,uy)+lambda*div(ux,uy)*div(ux,uy))//

problem elasticity([ux,uy],[vx,vy],solver=sparsesolver) =
  int2d(Th)(2*mu*e(ux,uy)'*e(vx,vy)+lambda*div(ux,uy)*div(vx,vy))
 -int1d(Th,GammaN)(N.x*vx+alpha*N.y*vy)
 +on(GammaD,ux=0,uy=0);

elasticity;
plot([ux,uy]);

real compliance = int2d(Th)(Aeueu(ux,uy));
cout << "Compliance: " << compliance << endl;

real compliance2 = int1d(Th,GammaN)(N.x*ux+alpha*N.y*uy);
cout << "Compliance: " << compliance2 << endl;

Vh0 grad;
grad = -Aeueu(ux,uy);

real valold = 1e100;

real aold,bold,cxold,cyold;


aold = a;
bold = b;
cxold = cx;
cyold = cy;

for(int i=1;i<maxiter;i++){
   // Compute angles in polar coordinates
   Vh thetas = atan2(y,x);
   plot(thetas,fill=1,wait=1,cmm="Compute the angles for the shape derivative");

   // Compute here the derivatives with respect to a and b
   // the center of the ellipse
   real derivx = int1d(Th,Gamma0)(grad*N.x);
   real derivy = int1d(Th,Gamma0)(grad*N.y);
   // the parameters of the ellipse
   real deriva = int1d(Th,Gamma0)(grad*(N.x*(x-cx)/a));
   real derivb = int1d(Th,Gamma0)(grad*(N.y*(y-cy)/b));

   real nxy = sqrt(derivx^2+derivy^2);
   real nab = sqrt(deriva^2+derivb^2);

   // normalize gradients since the difference is too big sometimes...
   // note that this also gives a descent direction
   derivx = derivx/nxy;
   derivy = derivy/nxy;
   deriva = deriva/nab;
   derivb = derivb/nab;

   // Gradient descent step
   cx = cx-step*derivx;
   cy = cy-step*derivy;
   a  = a-step*deriva;
   b  = b-step*derivb;

   // check to see if the ellipse can fit into the square
   a  = max(0.01,min(l-0.01,a));
   b  = max(0.01,min(l-0.01,b));



   // project on the area constraint
   projparams(a,b);

   // make sure that the center of the ellipse is compatible with the ellipse being interior to the square
   cx = max(cx,-l+a+0.1);
   cx = min(cx,l-a-0.1);
   cy = max(cy,-l+b+0.1);
   cy = min(cy,l-b-0.1);



   Th = buildmesh(left(2*NN)+bot(2*NN)+right(2*NN)+top(2*NN)
                   +superellipse(Ni*(a+b)*pi*NN));


   plot(Th,wait=1);

   elasticity;
   real compliance = int2d(Th)(Aeueu(ux,uy));


   if(compliance<valold){
       cout << "Accept" << endl;
       cout << "Compliance: " << compliance << endl;
        grad = -Aeueu(ux,uy);
        step = min(maxstep,1.1*step);
        aold = a;
        bold = b;
        cxold = cx;
        cyold = cy;
        valold = compliance;
   }
   else{
        cout << " Reject" << endl;
        step = step*0.5;
        a = aold;b=bold;cx=cxold;cy=cyold;
   }



}
