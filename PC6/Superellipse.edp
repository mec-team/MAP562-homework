//Homework 6 by Yucheng BU and Huihui ZHOU - Superellipse

// Geometric optimization of a parametric hole

real a=0.5,b=1,l=2;
real cx = 0,cy=0.5;
int maxiter = 200;
real maxstep = 0.01;
real ratio = 1;

real areah = 0;
real fixedV = 1;

real step = 0.05;

verbosity = 0;

real alpha =0.5;

real E=1;			// Young modulus
real nu=0.3;			// Poisson coefficient (between -1 and 1/2)

real lambda=E*nu/((1.+nu)*(1.-2.*nu));
real mu=E/(2.*(1.+nu));

int NN = 10;
int Ni = 1;

int GammaD = 0,GammaN = 1,Gamma0=20;

border left(t=l,-l){x=-l;y=t;label=GammaD;}
border bot(t=-l,l){x=t;y=-l;label=GammaN;}
border right(t=-l,l){x=l;y=t;label=GammaN;}
border top(t=l,-l){x=t;y=l;label=GammaN;}

// Parametric boundary
border superellipse(t=0,2*pi){
   x = a*((cos(t)>0)-(cos(t)<0))*sqrt(abs(cos(t)))+cx;
   y = b*((sin(t)>0)-(sin(t)<0))*sqrt(abs(sin(t)))+cy;
   label = Gamma0;
}


int integN = 100; //discretisation of the numeric integration of the area of the superellipse
macro projparams(a,b)
      areah = 0;

      /*numeric integration of the area of the superellipse*/
      for(int integi=1;integi<=integN;integi++){
        areah = areah + b*sqrt(sqrt(1-(integi/integN*a)^4/a^4))*a/integN;
      };
      /* project on the area constraint*/
      ratio = sqrt(areah*4/fixedV);
      a = a/ratio;
      b = b/ratio;//

projparams(a,b);

mesh Th = buildmesh(left(2*NN)+bot(2*NN)+right(2*NN)+top(2*NN)
                   +superellipse(-Ni*(a+b)*pi*NN));

plot(Th);

fespace Vh(Th,P1);
fespace Vh0(Th,P0);

Vh ux,uy,vx,vy;


real sqrt2 = sqrt(2);
macro e(ux,uy) [dx(ux),dy(uy),(dx(uy)+dy(ux))/sqrt2]//
macro div(ux,uy) (dx(ux)+dy(uy))//
macro Aeueu(ux,uy) (2*mu*e(ux,uy)'*e(ux,uy)+lambda*div(ux,uy)*div(ux,uy))//

problem elasticity([ux,uy],[vx,vy],solver=sparsesolver) =
  int2d(Th)(2*mu*e(ux,uy)'*e(vx,vy)+lambda*div(ux,uy)*div(vx,vy))
 -int1d(Th,GammaN)(N.x*vx+alpha*N.y*vy)
 +on(GammaD,ux=0,uy=0);

elasticity;
plot([ux,uy]);

real compliance = int2d(Th)(Aeueu(ux,uy));
cout << "Compliance: " << compliance << endl;

real compliance2 = int1d(Th,GammaN)(N.x*ux+alpha*N.y*uy);
cout << "Compliance: " << compliance2 << endl;

Vh0 grad;
grad = -Aeueu(ux,uy);

real valold = 1e100;

real aold,bold,cxold,cyold;


aold = a;
bold = b;
cxold = cx;
cyold = cy;

for(int i=1;i<maxiter;i++){

   // Compute here the derivatives with respect to a and b
   // the center of the ellipse
   real derivx = int1d(Th,Gamma0)(grad*N.x);
   real derivy = int1d(Th,Gamma0)(grad*N.y);
   // the parameters of the ellipse
   real deriva = int1d(Th,Gamma0)(grad*(N.x*(x-cx)/a));
   real derivb = int1d(Th,Gamma0)(grad*(N.y*(y-cy)/b));

   real nxy = sqrt(derivx^2+derivy^2);
   real nab = sqrt(deriva^2+derivb^2);

   // normalize gradients since the difference is too big sometimes...
   // note that this also gives a descent direction
   derivx = derivx/nxy;
   derivy = derivy/nxy;
   deriva = deriva/nab;
   derivb = derivb/nab;

   // Gradient descent step
   cx = cx-step*derivx;
   cy = cy-step*derivy;
   a  = a-step*deriva;
   b  = b-step*derivb;

   // check to see if the ellipse can fit into the square
   a  = max(0.01,min(l-0.01,a));
   b  = max(0.01,min(l-0.01,b));



   // project on the area constraint
   projparams(a,b);

   // make sure that the center of the ellipse is compatible with the ellipse being interior to the square
   cx = max(cx,-l+a+0.1);
   cx = min(cx,l-a-0.1);
   cy = max(cy,-l+b+0.1);
   cy = min(cy,l-b-0.1);



   Th = buildmesh(left(2*NN)+bot(2*NN)+right(2*NN)+top(2*NN)
                   +superellipse(-Ni*(a+b)*pi*NN));


   plot(Th,wait=0);

   elasticity;
   real compliance = int2d(Th)(Aeueu(ux,uy));


   if(compliance<valold){
       cout << "Accept" << endl;
       cout << "Compliance: " << compliance << endl;
        grad = -Aeueu(ux,uy);
        step = min(maxstep,1.1*step);
        aold = a;
        bold = b;
        cxold = cx;
        cyold = cy;
        valold = compliance;
   }
   else{
        cout << " Reject" << endl;
        step = step*0.5;
        a = aold;b=bold;cx=cxold;cy=cyold;
   }



}
plot(Th,cmm="final",wait=1);

/*
We can see that the algorithm optimises the position and the shape of the hole
through steps. It is remarkable that the hole has the tendence of getting out of
the square domain. It is reasonnable because if there's no hole, the deformation
and the compliance will sure be smaller. But this tentence is well restrained by
our restriction of the position of the whole.
*/
