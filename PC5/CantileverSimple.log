-- FreeFem++ v4.400003 (jeu. 12 dÃ©c. 2019 13:58:15 - git v4.4-3-9-gc37e08e1)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue
    1 : //Homework 5 by Yucheng BU and Huihui ZHOU
    2 : //single-load case
    3 :
    4 : real R = 2;
    5 : real r = 0.3;
    6 : real TOL = 1e-6;
    7 :
    8 : real hmin = 0.1;
    9 : real hmax = 1;
   10 : real h0   = 0.5;
   11 :
   12 : real alpha = 1;
   13 :
   14 : int maxiter = 30;
   15 : int iter;
   16 : verbosity = 0;
   17 :
   18 : real lag,lagmin,lagmax;
   19 : real vol0=h0,vol;
   20 :
   21 : int NN = 5;
   22 :
   23 : real E=2;                       // Young modulus
   24 : real nu=0.3;                    // Poisson coefficient (between -1 and 1/2)
   25 :
   26 : real lambda=E*nu/((1.+nu)*(1.-2.*nu));
   27 : real mu=E/(2.*(1.+nu));
   28 :
   29 : int GammaD = 0,GammaN1 = 1,GammaN2 = 2,GammaN3 = 3,Gamma = 100;
   30 :
   31 : border left(t=1,0)   {x=0;y=t;label=Gamma;}
   32 : border right(t=0,1)   {x=2;y=t;label=Gamma;}
   33 : border top(t=2,0) {x=t;y=1;label=Gamma;}
   34 : border sd1(t=0,0.1)   {x=t;y=0;label=GammaD;}
   35 : border s1(t=0.1,0.4)  {x=t;y=0;label=Gamma;}
   36 : border s2(t=0.4,0.7)  {x=t;y=0;label=GammaN2;}
   37 : border s3(t=0.7,0.85) {x=t;y=0;label=Gamma;}
   38 : border s4(t=0.85,1.15){x=t;y=0;label=GammaN1;}
   39 : border s5(t=1.15,1.3) {x=t;y=0;label=Gamma;}
   40 : border s6(t=1.3,1.6)  {x=t;y=0;label=GammaN3;}
   41 : border s7(t=1.6,1.9)    {x=t;y=0;label=Gamma;}
   42 : border sd2(t=1.9,2)    {x=t;y=0;label=GammaD;}
   43 :
   44 : mesh Th = buildmesh(left(10*NN)+sd1(NN)+s1(3*NN)+s2(3*NN)+s3(1.5*NN)+s4(3*NN)+s5(1.5*NN)+s6(3*NN)+s7(3*NN)+sd2(NŸ9„V‹ô?N)+right(10*NN)+top(20*NN));
   45 : plot(Th,wait=1);
   46 :
   47 : fespace Vh0(Th,P0);
   48 : fespace Vh2(Th,[P2,P2]);
   49 :
   50 : Vh2 [u,v],[w,s],[u1,v1],[u2,v2],[u3,v3];
   51 : Vh0 h,hold,density,newh;
   52 : Vh0 Aeueu;
   53 :
   54 : Vh2 [gx1,gy1],[gx2,gy2],[gx3,gy3];
   55 :
   56 : [gx1,gy1] = [0,-1];
   57 : [gx2,gy2] = [0,-1];
   58 : [gx3,gy3] = [0,-1];
   59 :
   60 : h = 1+0.1*x^2;
   61 : real avg = 1/Th.area*int2d(Th)(h);
   62 :
   63 : h = h-avg+h0;
   64 :
   65 : real sqrt2 = sqrt(2);
   66 : int[int] k(3);
   67 :
   68 : macro e(u,v) [dx(u),dy(v),(dx(v)+dy(u))/sqrt2] )  //
   69 : macro div(u,v) (dx(u)+dy(v)) )  //
   70 :
   71 : problem elasticity([u,v],[w,s]) =
   72 :     int2d(Th)(2.*mu*h*e(u,v)  [dx(u),dy(v),(dx(v)+dy(u))/sqrt2]'*e(w,s)  [dx(w),dy(s),(dx(s)+dy(w))/sqrt2]
   73 :              +h*lambda*div(u,v)  (dx(u)+dy(v))*div(w,s)  (dx(w)+dy(s)))
   74 :     -int1d(Th,GammaN1)((gx1*w+gy1*s))
   75 :     -int1d(Th,GammaN2)((gx2*w+gy2*s))
   76 :     -int1d(Th,GammaN3)((gx3*w+gy3*s))
   77 :     +on(GammaD,u=0,v=0);
   78 :
   79 : elasticity;
   80 :
   81 : real compliance = int1d(Th,GammaN1)(gx1*u+gy1*v)
   82 :                   +int1d(Th,GammaN2)(gx2*u+gy2*v)
   83 :                   +int1d(Th,GammaN3)(gx3*u+gy3*v);
   84 :
   85 : cout << "Compliance: " << compliance << endl;
   86 :
   87 : // Macro for truncation
   88 : macro trunc(u,mm,MM) min(max(u,mm),MM) )  // END of macro
   89 :
   90 : real[int] vals(1);
   91 : vals[0]=compliance;
   92 :
   93 : for(iter=1;iter<maxiter;iter++){
   94 :
   95 :   Aeueu = h^2*(2*mu*e(u,v)  [dx(u),dy(v),(dx(v)+dy(u))/sqrt2]'*e(u,v)  [dx(u),dy(v),(dx(v)+dy(u))/sqrt2]+lambda*Ÿ9„V‹ô?div(u,v)  (dx(u)+dy(v))*div(u,v)  (dx(u)+dy(v)));
   96 :
   97 :   // upper bound lagmax
   98 :   lagmax = Aeueu[].max/hmin^2;
   99 :   newh = trunc(sqrt(1/lagmax*Aeueu),hmin,hmax)  min(max(sqrt(1/lagmax*Aeueu),hmin),hmax);
  100 :   cout <<"Lagmax: " << lagmax << "  Min: " << newh[].min << "   Max: " << newh[].max << endl;
  101 :
  102 :   // lower bound lagmin
  103 :   lagmin = Aeueu[].min/hmax^2;
  104 :   newh = trunc(sqrt(1/lagmin*Aeueu),hmin,hmax)  min(max(sqrt(1/lagmin*Aeueu),hmin),hmax);
  105 :   cout <<"Lagmin: " << lagmin << " Min: " << newh[].min << "   Max: " << newh[].max << endl;
  106 :
  107 :   // dichotomy
  108 :
  109 :   while(abs(lagmax-lagmin)>TOL || abs(vol-vol0)>TOL){
  110 :      lag = 0.5*(lagmax+lagmin);   // look at midpoint
  111 :      newh =  trunc(sqrt(1/lag*Aeueu),hmin,hmax)  min(max(sqrt(1/lag*Aeueu),hmin),hmax);
  112 :      vol = 1/Th.area*int2d(Th)(newh);
  113 :      if(vol<vol0){
  114 :         lagmax = lag;
  115 :      }
  116 :      else{
  117 :         lagmin = lag;
  118 :      }
  119 :   }
  120 :   hold = h;
  121 :   h =  trunc(sqrt(1/lag*Aeueu),hmin,hmax)  min(max(sqrt(1/lag*Aeueu),hmin),hmax);
  122 :   vol = 1/Th.area*int2d(Th)(h);
  123 :   //lagmin = Aeueu[].
  124 :
  125 :   elasticity;
  126 :   compliance = int1d(Th,GammaN1)(gx1*u+gy1*v)
  127 :                     +int1d(Th,GammaN2)(gx2*u+gy2*v)
  128 :                     +int1d(Th,GammaN3)(gx3*u+gy3*v);
  129 :   vals = [vals,compliance];
  130 :
  131 :   cout << "Iteration #" << iter << " | Compliance " << compliance << "   Vol frac. " << vol << endl;
  132 :   //exit(0);
  133 :
  134 :   plot(h,fill=1,value=1,wait=0);
  135 :
  136 :   // stopping criterion
  137 :   Vh0 diff = abs(h-hold);
  138 :   if(diff[].max<TOL){break;}
  139 :
  140 : }
  141 :
  142 : real[int] dis = 1:vals.n;
  143 : plot(h,fill=1,value=1,cmm ="Final h", wait=1);
  144 :
  145 : plot([dis,vals],cmm="Evoluion of cost function");
  146 :
  147 : /*
  148 : The results obtained in the single-load case and the multi-load case are different.
  149 : And that's because our objective is different. In the single-load case we try to
  150 : optimise the deformation caused by three forces applied simultaneously. In the
  151 : multi-load case, we compromise among three cases where only one border force is
  152 : active in each case. The objective function (the compliance) of these two cases
  153 : are thus different. For the single-load case, we apply three forces to the system
  154 : at the same time and calculate directly the compliance. For the multi-load case,
  155 : we optimise the sum of the compliance of the three sub-cases (only one force in
  156 : each one). But the compliance caused by each force cannot be linearly added to get
  157 : the compliance of three forces, so we get different results for these two cases.
  158 : */
  159 :  sizestack + 1024 =8872  ( 7848 )
 
Compliance: 1.77527
Lagmax: 4949.34  Min: 0.1   Max: 0.1
Lagmin: 2.24358e-07 Min: 1   Max: 1
Iteration #1 | Compliance 1.30967   Vol frac. 0.5
Lagmax: 5421.18  Min: 0.1   Max: 0.1
Lagmin: 5.12072e-08 Min: 1   Max: 1
Iteration #2 | Compliance 1.29675   Vol frac. 0.5
Lagmax: 5585.22  Min: 0.1   Max: 0.1
Lagmin: 4.45273e-08 Min: 1   Max: 1
Iteration #3 | Compliance 1.29195   Vol frac. 0.5
Lagmax: 5648.16  Min: 0.1   Max: 0.1
Lagmin: 4.01909e-08 Min: 1   Max: 1
Iteration #4 | Compliance 1.28942   Vol frac. 0.5
Lagmax: 5684.08  Min: 0.1   Max: 0.1
Lagmin: 3.7334e-08 Min: 1   Max: 1
Iteration #5 | Compliance 1.28787   Vol frac. 0.5
Lagmax: 5709.86  Min: 0.1   Max: 0.1
Lagmin: 3.53186e-08 Min: 1   Max: 1
Iteration #6 | Compliance 1.28683   Vol frac. 0.5
Lagmax: 5730.67  Min: 0.1   Max: 0.1
Lagmin: 3.38303e-08 Min: 1   Max: 1
Iteration #7 | Compliance 1.2861   Vol frac. 0.5
Lagmax: 5747.5  Min: 0.1   Max: 0.1
Lagmin: 3.27107e-08 Min: 1   Max: 1
Iteration #8 | Compliance 1.28556   Vol frac. 0.5
Lagmax: 5761.67  Min: 0.1   Max: 0.1
Lagmin: 3.18473e-08 Min: 1   Max: 1
Iteration #9 | Compliance 1.28515   Vol frac. 0.5
Lagmax: 5773.76  Min: 0.1   Max: 0.1
Lagmin: 3.11602e-08 Min: 1   Max: 1
Iteration #10 | Compliance 1.28483   Vol frac. 0.5
Lagmax: 5784.34  Min: 0.1   Max: 0.1
Lagmin: 3.06006e-08 Min: 1   Max: 1
Iteration #11 | Compliance 1.28458   Vol frac. 0.5
Lagmax: 5793.57  Min: 0.1   Max: 0.1
Lagmin: 3.01485e-08 Min: 1   Max: 1
Iteration #12 | Compliance 1.28437   Vol frac. 0.5
Lagmax: 5801.77  Min: 0.1   Max: 0.1
Lagmin: 2.97742e-08 Min: 1   Max: 1
Iteration #13 | Compliance 1.2842   Vol frac. 0.5
Lagmax: 5809.02  Min: 0.1   Max: 0.1
Lagmin: 2.947e-08 Min: 1   Max: 1
Iteration #14 | Compliance 1.28406   Vol frac. 0.5
Lagmax: 5815.46  Min: 0.1   Max: 0.1
Lagmin: 2.92069e-08 Min: 1   Max: 1
Iteration #15 | Compliance 1.28394   Vol frac. 0.5
Lagmax: 5821.22  Min: 0.1   Max: 0.1
Lagmin: 2.8979e-08 Min: 1   Max: 1
Iteration #16 | Compliance 1.28384   Vol frac. 0.5
Lagmax: 5826.42  Min: 0.1   Max: 0.1
Lagmin: 2.87874e-08 Min: 1   Max: 1
Iteration #17 | Compliance 1.28375   Vol frac. 0.5
Lagmax: 5831.09  Min: 0.1   Max: 0.1
Lagmin: 2.86203e-08 Min: 1   Max: 1
Iteration #18 | Compliance 1.28368   Vol frac. 0.5
Lagmax: 5835.3  Min: 0.1   Max: 0.1
Lagmin: 2.84727e-08 Min: 1   Max: 1
Iteration #19 | Compliance 1.28361   Vol frac. 0.5
Lagmax: 5839.1  Min: 0.1   Max: 0.1
Lagmin: 2.83415e-08 Min: 1   Max: 1
Iteration #20 | Compliance 1.28355   Vol frac. 0.5
Lagmax: 5842.57  Min: 0.1   Max: 0.1
Lagmin: 2.82283e-08 Min: 1   Max: 1
Iteration #21 | Compliance 1.2835   Vol frac. 0.5
Lagmax: 5845.75  Min: 0.1   Max: 0.1
Lagmin: 2.81362e-08 Min: 1   Max: 1
Iteration #22 | Compliance 1.28346   Vol frac. 0.5
Lagmax: 5848.67  Min: 0.1   Max: 0.1
Lagmin: 2.80608e-08 Min: 1   Max: 1
Iteration #23 | Compliance 1.28342   Vol frac. 0.5
Lagmax: 5851.38  Min: 0.1   Max: 0.1
Lagmin: 2.79968e-08 Min: 1   Max: 1
Iteration #24 | Compliance 1.28338   Vol frac. 0.5
Lagmax: 5853.87  Min: 0.1   Max: 0.1
Lagmin: 2.7943e-08 Min: 1   Max: 1
Iteration #25 | Compliance 1.28335   Vol frac. 0.5
Lagmax: 5856.16  Min: 0.1   Max: 0.1
Lagmin: 2.78966e-08 Min: 1   Max: 1
Iteration #26 | Compliance 1.28332   Vol frac. 0.5
Lagmax: 5858.29  Min: 0.1   Max: 0.1
Lagmin: 2.7855e-08 Min: 1   Max: 1
Iteration #27 | Compliance 1.2833   Vol frac. 0.5
Lagmax: 5860.27  Min: 0.1   Max: 0.1
Lagmin: 2.7814e-08 Min: 1   Max: 1
Iteration #28 | Compliance 1.28327   Vol frac. 0.5
Lagmax: 5862.15  Min: 0.1   Max: 0.1
Lagmin: 2.77734e-08 Min: 1   Max: 1
Iteration #29 | Compliance 1.28325   Vol frac. 0.5
 try getConsole F:\github-clone\MAP562-homework\PC5\CantileverSimple.edp
